---
// src/views/Recipes/index.astro
import { getLocale } from '../../i18n/i18n';
import './styles.css';
import RecipeCardLarge from '../../components/recipes/RecipeCardLarge.astro';
import RecipeCardSmall from '../../components/recipes/RecipeCardSmall.astro';
import RecipeCard from '../../components/recipes/RecipeCard.astro';

interface Recipe {
  id: string;
  title: string;
  image?: string;
  preparation_time: number;
  type?: string;
  category?: string;
  product?: string | string[];
  difficulty?: string;
}

const currentLang = getLocale();

// Get all recipe files with correct Vite glob typing
const recipeModules = import.meta.glob<{default: Recipe}>('../../locales/*/recipes/*.json');
const allRecipes: Recipe[] = [];

// Process each file
for (const path in recipeModules) {
  const lang = path.split('/')[3];
  if (lang === currentLang) {
    const module = await recipeModules[path]();
    allRecipes.push(module.default);
  }
}

// Shared translations
const noRecipesText = currentLang === 'es' 
  ? 'No hay recetas disponibles en este momento.' 
  : 'No recipes available at this time.';
const noFilterResultsText = currentLang === 'es'
  ? 'No se encontraron resultados para la selección'
  : 'No results found for the selection';

// Filter labels
const filterLabels = currentLang === 'es'
  ? { 
      typeLabel: 'Tipo',
      productLabel: 'Producto',
      searchPlaceholder: 'Buscar producto...',
      all: 'Todos',
      breakfast: 'Desayuno', 
      brunch: 'Brunch',
      lunch: 'Almuerzo',
      dinner: 'Cena',
      snack: 'Snack'
    }
  : {
      typeLabel: 'Type',
      productLabel: 'Product',
      searchPlaceholder: 'Search product...',
      all: 'All',
      breakfast: 'Breakfast',
      brunch: 'Brunch',
      lunch: 'Lunch',
      dinner: 'Dinner',
      snack: 'Snack'
    };

// Normaliza la categoría de receta
function normalizeType(r: Recipe): string {
  const rawCategory = String((r as any).category || '').toLowerCase().trim();
  
  // Mapeo directo de categorías válidas
  const categoryMap: Record<string, string> = {
    'breakfast': 'breakfast',
    'brunch': 'brunch', 
    'lunch': 'lunch',
    'dinner': 'dinner',
    'snack': 'snack'
  };
  
  return categoryMap[rawCategory] || 'other';
}

// Obtener categorías únicas disponibles
const uniqueCategories = [...new Set(allRecipes.map(r => normalizeType(r)).filter(cat => cat !== 'other'))];

// Cargar catálogo de productos desde locales por idioma actual
interface ProductItem { id: string; name: string; description?: string; }
const productModules = import.meta.glob<{ default: { items: ProductItem[] } }>('../../locales/*/products.json');
const productMap: Record<string, ProductItem> = {};

for (const path in productModules) {
  const lang = path.split('/')[3];
  if (lang === currentLang) {
    const mod = await productModules[path]();
    for (const item of (mod.default.items || [])) {
      productMap[item.id] = item;
    }
  }
}

// Opciones de productos para el selector: tomar TODOS los productos del catálogo del idioma actual
const uniqueProducts = Object.keys(productMap);

// Dividir recetas: primera destacada, siguientes 3 en sidebar, resto en grid
const featuredRecipe = allRecipes[0];
const sidebarRecipes = allRecipes.slice(1, 4);
const gridRecipes = allRecipes.slice(4);
---

<div class="overflow-hidden bg-primaryCream">
  
  <div class="container ml-[40px] mt-[40px] mr-[40px] mb-20 ">

    <!-- Header -->
    <div class="mb-4">
      <h1 class="text-[64px] font-bold leading-tight">
        {currentLang==='es' ? 'Recetas' : 'Recipes'}
        <span class="text-orange">{currentLang==='es' ? 'Ranchitas' : 'Ranchitas'}</span>
      </h1>
    </div>
    
    <div class="mb-8">
      <p class="text-[18px]">
        {currentLang==='es' 
          ? 'Descubre formas deliciosas y creativas de disfrutar tus Ranchitas favoritas. Desde snacks rápidos hasta platos principales.' 
          : 'Discover delicious and creative ways to enjoy your favorite Ranchitas. From quick snacks to main dishes.'}
      </p>
    </div>

    <!-- Filter Section -->
    <div class="flex flex-col md:flex-row gap-4 mb-12">
      <!-- Tipo Filter -->
      <div class="relative">
        <select 
          id="typeFilter" 
          class="appearance-none bg-white rounded-full px-6 py-3 pr-10 text-base font-medium border-0 shadow-sm cursor-pointer hover:shadow-md transition-shadow focus:outline-none focus:ring-2 focus:ring-orange"
        >
          <option value="all">{filterLabels.typeLabel}: {filterLabels.all}</option>
          {uniqueCategories.includes('breakfast') && <option value="breakfast">{filterLabels.typeLabel}: {filterLabels.breakfast}</option>}
          {uniqueCategories.includes('brunch') && <option value="brunch">{filterLabels.typeLabel}: {filterLabels.brunch}</option>}
          {uniqueCategories.includes('lunch') && <option value="lunch">{filterLabels.typeLabel}: {filterLabels.lunch}</option>}
          {uniqueCategories.includes('dinner') && <option value="dinner">{filterLabels.typeLabel}: {filterLabels.dinner}</option>}
          {uniqueCategories.includes('snack') && <option value="snack">{filterLabels.typeLabel}: {filterLabels.snack}</option>}
        </select>
        <svg class="hidden md:block absolute right-4 top-1/2 -translate-y-1/2 w-4 h-4 pointer-events-none" fill="currentColor" viewBox="0 0 20 20">
          <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"/>
        </svg>
      </div>

      <!-- Producto Filter -->
      <div class="relative">
        <select 
          id="productFilter" 
          class="appearance-none bg-white rounded-full px-6 py-3 pr-10 text-base font-medium border-0 shadow-sm cursor-pointer hover:shadow-md transition-shadow focus:outline-none focus:ring-2 focus:ring-orange"
        >
          <option value="all">{filterLabels.productLabel}: {filterLabels.all}</option>
          {uniqueProducts.map(productId => (
            <option value={productId}>{filterLabels.productLabel}: {productMap[productId]?.name || productId}</option>
          ))}
        </select>
        <svg class="hidden md:block absolute right-4 top-1/2 -translate-y-1/2 w-4 h-4 pointer-events-none" fill="currentColor" viewBox="0 0 20 20">
          <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"/>
        </svg>
      </div>

      <!-- Product info (shown when a product is selected) -->
      <div id="productInfo" class="hidden flex-1 bg-white rounded-xl px-6 py-4 border border-gray-100 shadow-sm">
        <!-- content set by script based on selected product -->
      </div>

      
    </div>

    <h2 id="featuredTitle" class="text-[42px] font-bold mb-8">
      {currentLang==='es' ? 'Las más populares del momento' : 'The most popular ones right now'}
    </h2>

    {allRecipes.length === 0 ? (
      <p class="text-center text-gray-500">{noRecipesText}</p>
    ) : (
      <>
        <div id="featuredSection" class="grid grid-cols-1 lg:grid-cols-12 gap-6 mb-16">
          {featuredRecipe && (
            <div 
              class="lg:col-span-8 recipe-card" 
              data-type={normalizeType(featuredRecipe)}
              data-products={(Array.isArray(featuredRecipe.product) ? featuredRecipe.product : (featuredRecipe.product ? [featuredRecipe.product] : [])).join(',')}
              data-title={featuredRecipe.title.toLowerCase()}
            >
              <RecipeCardLarge
                image={featuredRecipe.image || '/images/recipes/placeholder.jpg'}
                title={featuredRecipe.title}
                time={`${featuredRecipe.preparation_time} min`}
                id={featuredRecipe.id}
                difficulty={featuredRecipe.difficulty || (currentLang === 'es' ? 'Fácil' : 'Easy')}
                product={Array.isArray(featuredRecipe.product) ? featuredRecipe.product[0] : featuredRecipe.product}
                category={normalizeType(featuredRecipe)}
              />
            </div>
          )}
          
          <div class="lg:col-span-4 flex flex-col gap-4 justify-between">
            {sidebarRecipes.map((recipe: Recipe) => (
              <div 
                class="recipe-card" 
                data-type={normalizeType(recipe)}
                data-products={(Array.isArray(recipe.product) ? recipe.product : (recipe.product ? [recipe.product] : [])).join(',')}
                data-title={recipe.title.toLowerCase()}
              >
                <RecipeCardSmall
                  image={recipe.image || '/images/recipes/placeholder.jpg'}
                  title={recipe.title}
                  id={recipe.id}
                  product={Array.isArray(recipe.product) ? recipe.product[0] : recipe.product}
                  category={normalizeType(recipe)}
                />
              </div>
            ))}
          </div>
        </div>
        <!-- No results message -->
        <div id="noResults" class="hidden mt-12 items-center justify-center h-48">
          <p class="text-gray-500 text-lg font-medium">{noFilterResultsText}</p>
        </div>
      </>
    )}

  <h2 class="text-[42px] font-bold mb-8">{currentLang === 'es' ? 'Descubre más recetas' : 'Discover more recipes' }</h2>
  {allRecipes.length === 0 ? (
    <p class="text-center text-gray-500">{noRecipesText}</p>
  ) : (
    <div id="recipesGrid" class="w-full mx-auto grid grid-cols-1 sm:grid-cols-2 gap-6 md:gap-10 mt-12" transition:animate="slide">
      {allRecipes.map((recipe: Recipe) => (
        <div class="recipe-card" 
             data-type={normalizeType(recipe)}
             data-products={(Array.isArray(recipe.product) ? recipe.product : (recipe.product ? [recipe.product] : [])).join(',')}
             data-title={recipe.title.toLowerCase()}>
          <RecipeCard
            image={recipe.image || '/images/recipes/placeholder.jpg'}
            title={recipe.title}
            time={`${recipe.preparation_time}MIN`}
            id={recipe.id}
            textColor="text-white"
            iconColor="text-white"
          />
        </div>
      ))}
    </div>
    <!-- No results message for filters -->
    <div id="noResultsGrid" class="hidden mt-6 items-center justify-center h-48 md:h-64">
      <span class="text-[#D61F2C] text-lg md:text-xl font-semibold">{noFilterResultsText}</span>
    </div>
    <!-- Infinite scroll sentinel -->
    <div id="infiniteSentinel" class="w-full h-10"></div>
  )}
  </div>
  
</div>

<!-- Serialized product map for client-side consumption -->
<script type="application/json" id="product-map">{JSON.stringify(productMap)}</script>

<script is:inline>
  // REINGENIERÍA DEL SISTEMA DE FILTRADO
  // Ejecutar inmediatamente sin esperar eventos del DOM
  (function() {
    'use strict';
    
    // Parse product map
    let PRODUCT_MAP = {};
    try {
      const mapEl = document.getElementById('product-map');
      if (mapEl && mapEl.textContent) {
        PRODUCT_MAP = JSON.parse(mapEl.textContent);
      }
    } catch(e) {
      console.error('Error parsing product map:', e);
    }

    function applyFilters() {
      // Get filter elements
      const typeFilter = document.getElementById('typeFilter');
      const productFilter = document.getElementById('productFilter');
      const productInfo = document.getElementById('productInfo');
      const featuredTitle = document.getElementById('featuredTitle');
      const featuredSection = document.getElementById('featuredSection');
      const recipesGrid = document.getElementById('recipesGrid');
      const noResults = document.getElementById('noResults');
      const noResultsGrid = document.getElementById('noResultsGrid');
      
      if (!typeFilter || !productFilter) {
        console.warn('Filters not found, retrying...');
        return;
      }

      // Get current filter values
      const typeValue = typeFilter.value || 'all';
      const productValue = productFilter.value || 'all';

      // Detectar si hay filtros activos
      const hasActiveFilters = typeValue !== 'all' || productValue !== 'all';

      // Get all recipe cards
      const recipeCards = document.querySelectorAll('.recipe-card');
      let visibleCount = 0;

      // Apply filters to each card
      recipeCards.forEach(function(card) {
        const cardType = card.getAttribute('data-type') || '';
        const cardProductsStr = card.getAttribute('data-products') || '';
        const cardProducts = cardProductsStr.split(',').filter(function(p) { return p.trim() !== ''; });

        // Check if card matches filters
        const matchesType = typeValue === 'all' || cardType === typeValue;
        const matchesProduct = productValue === 'all' || cardProducts.indexOf(productValue) !== -1;
        const isVisible = matchesType && matchesProduct;

        // Show/hide card
        card.style.display = isVisible ? '' : 'none';
        if (isVisible) visibleCount++;
      });

      // Show/hide sections based on filters and results
      const hasResults = visibleCount > 0;
      
      // Si hay filtros activos, ocultar la sección "Las más populares" y su título
      if (featuredTitle) {
        if (hasActiveFilters) {
          featuredTitle.style.display = 'none';
        } else {
          featuredTitle.style.display = '';
        }
      }
      
      if (featuredSection) {
        if (hasActiveFilters) {
          featuredSection.style.display = 'none';
        } else {
          featuredSection.style.display = hasResults ? '' : 'none';
        }
      }
      
      // El grid siempre se muestra si hay resultados
      if (recipesGrid) {
        recipesGrid.style.display = hasResults ? '' : 'none';
      }
      
      // Handle no results messages
      if (noResults) {
        // Solo mostrar mensaje en featured si NO hay filtros activos y no hay resultados
        if (!hasActiveFilters && !hasResults) {
          noResults.classList.remove('hidden');
          noResults.classList.add('flex');
        } else {
          noResults.classList.add('hidden');
          noResults.classList.remove('flex');
        }
      }
      
      if (noResultsGrid) {
        if (hasResults) {
          noResultsGrid.classList.add('hidden');
          noResultsGrid.classList.remove('flex');
        } else {
          noResultsGrid.classList.remove('hidden');
          noResultsGrid.classList.add('flex');
        }
      }

      // Update product info panel
      if (productInfo) {
        const selected = productValue !== 'all' ? PRODUCT_MAP[productValue] : null;
        if (selected) {
          const title = selected.name || productValue;
          const desc = selected.description || '';
          productInfo.innerHTML = '<div class="flex flex-col gap-1"><div class="text-base font-semibold text-gray-900">' + title + '</div>' + (desc ? '<div class="text-sm text-gray-600">' + desc + '</div>' : '') + '</div>';
          productInfo.classList.remove('hidden');
          productInfo.classList.add('flex');
        } else {
          productInfo.classList.add('hidden');
          productInfo.classList.remove('flex');
          productInfo.innerHTML = '';
        }
      }
    }

    // Attach event listeners
    function attachListeners() {
      const typeFilter = document.getElementById('typeFilter');
      const productFilter = document.getElementById('productFilter');
      
      if (typeFilter) {
        typeFilter.addEventListener('change', applyFilters);
      }
      if (productFilter) {
        productFilter.addEventListener('change', applyFilters);
      }
    }

    // Initialize: try immediately, then on DOMContentLoaded, then on load
    function init() {
      attachListeners();
      applyFilters();
    }

    // Try to run immediately
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }
    
    // Fallback for late-loading content
    window.addEventListener('load', applyFilters);
  })();
</script>

<style>
  select {
    background-image: none;
  }
  
  select:hover, input:hover {
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
  }

  .line-clamp-2 {
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }
</style>